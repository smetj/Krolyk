#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       krolyk.py
#       
#       Copyright 2011 Jelle Smet <development@smetj.net>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#       
#       

import logging
import os
import sys
import pika
import time
from multiprocessing import Process, Manager, Queue
from pika.adapters import SelectConnection
from logging.handlers import SysLogHandler
from optparse import OptionParser
from configobj import ConfigObj
from string import find

__version__='0.2'

class Worker(Process):
    def __init__(self,config,cb_consume,block):
        Process.__init__(self)
        self.logging = logging.getLogger(__name__)
        self.c=config
        self.cb_consume=cb_consume
        self.block=block
        self.daemon=True
    def run(self):
        while self.block() == True:
            try:
                self.logging.debug('Started.')
                credentials = pika.PlainCredentials(self.c['_user'],self.c['_password'])
                self.parameters = pika.ConnectionParameters(self.c['_broker'],credentials=credentials)
                self.connection = SelectConnection(self.parameters,self.__on_connected) 
                try:
                    self.connection.ioloop.start()
                except KeyboardInterrupt:
                    self.connection.close()
                    self.connection.ioloop.start()
                    break
            except:
                self.logging.debug('Lost connection to Broker, sleeping and restarting.')
                time.sleep(1)               
    def __on_connected(self,connection):
        self.logging.info('Connecting to broker.')
        connection.channel(self.__on_channel_open)
    def __on_channel_open(self,new_channel):
        self.channel = new_channel
        self.__initialize()
        self.channel.basic_qos(prefetch_count=1)
        self.channel.basic_consume(self.cb_consume, queue = self.c['_queue'])
    def __initialize(self):
        self.logging.debug('Creating queues and bindings on broker.')                
        self.channel.queue_declare(queue=self.c['_queue'],durable=True)
    def acknowledge(self,tag):
        self.channel.basic_ack(delivery_tag=tag)

class ModManager():
    def __init__(self, cfg, block):
        self.logging = logging.getLogger(__name__)
        self.cfg=cfg
        self.block=block
        self.register={}
        self.__load()        
    def __load(self):
        for module in self.cfg:
            if self.cfg[module]['_enabled'] == 'True':
                try:
                    self.logging.info('Module %s enabled importing.' % module)
                    import plugins
                    self.register[module]={}
                    for counter in range(int(self.cfg[module]['_workers'])):
                        self.register[module][counter]={}
                        self.register[module][counter]['mod'] = getattr(plugins,module)(self.__cleanConfig(self.cfg[module]))
                        self.register[module][counter]['mod'].block = self.block
                                                
                        self.register[module][counter]['proc'] = Worker(config=self.cfg[module],
                                                                    cb_consume=self.register[module][counter]['mod'].consume,
                                                                    block=self.block)

                        self.register[module][counter]['mod'].acknowledge = self.register[module][counter]['proc'].acknowledge
                        
                        self.register[module][counter]['proc'].start()
                except Exception as err:
                    self.logging.warning('Failed to load module %s. Reason: %s' % (module, err))
            else:
                self.logging.info('Module %s disabled.' % module)
    def __cleanConfig(self, config):
        cleaned={}
        for item in config:
            if find(item,'_') !=0:
                cleaned[item]=config[item]
        return cleaned
        
class Server():
    '''Server class handling process control, startup & shutdown'''
    def __init__(self, config=None):
        self.cfg=None
        self.load_config(config)
        self.procs = []
        self.lock = True
    def load_config(self, file):
        try:
            self.cfg = ConfigObj(file)
            sys.path.append(self.cfg['application']['plugins'])
        except Exception as err:
            print "Error reading config file. Reason: %s" % (err)
            sys.exit(1)        
    def block(self):
        return self.lock
    def doPID(self):
        if self.checkPIDRunning() == False:
            self.writePID()
    def checkPIDRunning(self):
        '''Checks whether the pid file exists and if it does, checks whether a process is running with that pid.
        Returns False when no process is running with that pid otherwise True'''
        if os.path.isfile(self.cfg['application']['pid']):
            try:
                pid_file = open(self.cfg['application']['pid'], 'r')
                pid=pid_file.readline()
                pid_file.close()
            except Exception as err:
                sys.stderr.write('I could not open the pid file. Reason: %s\n'%(err))
                sys.exit(1)
        try:
            os.kill(int(pid),0)
        except:
            return False
        else:
            sys.stderr.write('There is already a process running with pid %s\n'%(pid))
            sys.exit(1)             
    def writePID(self):
        try:
            pid = open ( self.cfg['application']['pid'], 'w' )
            pid.write (str(os.getpid()))
            pid.close()
        except Exception as err:
            sys.stderr.write('I could not write the pid file. Reason: %s\n'%(err))
            sys.exit(1)
    def deletePID(self):
        try:
            os.remove ( self.cfg['application']['pid'] )
        except:
            pass                
    def start(self):
        #Creating logging object
        self.logger()
        self.logging = logging.getLogger(__name__)

        self.logging.info('started')

        #Write PID
        self.doPID()
        
        #Initiate ModManager
        self.mod = ModManager(block=self.block,cfg=self.cfg['plugins'])
        
        while self.block()==True:
            time.sleep(0.1)
        
        self.logging.info('Exit')
    def stop(self):
        self.logging.info('Received stop. Starting stop sequence.')
        self.block=False
        for module in self.mod.register:
            for instance in self.mod.register[module]:
                if self.mod.register[module][instance].has_key('proc'):
                    self.mod.register[module][instance]['proc'].join()
    def logger(self,file=None, loglevel=logging.WARNING):
        format=('%(asctime)s %(levelname)s %(name)s %(message)s')
        if file == None:
            logging.basicConfig(level=loglevel, format=format)
        else:
            print file
            logging.basicConfig(filename=file, level=loglevel, format=format)
            
class Help():
    def __init__(self):
        print ('Krolyk %s Copyright 2011 by Jelle Smet <development@smetj.net>' %(__version__))
        print ('''
        
Description:

    Krolyk is a framework which allows you to easily register a Python class as a process 
    to consume and process data coming from a RabbitMQ message broker.
    
Usage:
        
    krolyk command --config name
    
    Valid commands:

        start       Starts Krolyk and forks into the background.        (not implemented yet)
        stop        Stops Krolyk.                                       (not implemented yet)
        debug       Starts Krolyk into the foreground.
        help        Shows this help message.
    

    Parameters:

        --config    Defines the location of the config file.


Config file:

The config file contains a section called "plugins"
Each class has its own section under plugins.  The name of the module section should match the name of your class.
Your module (which contains the class) should be stored in the plugins/ directory.

Each section should contain at least following parameters:
    
        "_enabled"       = True
        "_workers"       = 5
        "_broker"        = "sandbox"
        "_queue"         = "molog_output"
        "_user"          = "guest"
        "_password"      = "guest"

These are used to connect your class to the right queue.
You can define as much extra parameters as you want (without leading underscore)

Your class will receive 2 methods and 1 dictionary object from the Krolyk framework:

    self.acknowledge    Krolyk method which acknowledges the data coming from the queue.
    self.block          Krolyk method to check whether the main loop is going to exit.


For bugs please submit a bugreport to: 
    https://github.com/smetj/krolyk/issues



Krolyk is distributed under the Terms of the GNU General Public License Version 3. (http://www.gnu.org/licenses/gpl-3.0.html)

For more information please visit http://www.smetj.net/krolyk/
        ''')


if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option("--config", dest="config", default="/opt/krolyk/etc/krolyk.conf", type="string", help="The location of the config file." )
    (cli_options,cli_actions)=parser.parse_args()   
    
    try:
        server=Server(config = cli_options.config)
        if len (cli_actions) == 0:
            Help()
            sys.exit(0)
        if cli_actions[0] == 'help':
            Help()
            sys.exit(0)
        elif cli_actions[0] == 'start':
            with daemon.DaemonContext():
                server.start()
        elif cli_actions[0] == 'debug':
            server.start()
    except Exception as err:
        print str(err)
    except KeyboardInterrupt:
        server.stop()
        server.deletePID()
