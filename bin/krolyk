#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       krolyk.py
#       
#       Copyright 2011 Jelle Smet <development@smetj.net>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#       
#       


import logging
import sys
import daemon
import os
import time
try:
    import krolyk
except:
    print "Please set $PYTHONPATH to include the directory containing the Krolyk libs.\n"
    sys.exit(1)
from optparse import OptionParser
from configobj import ConfigObj
       
class Server():
    '''Server class handling process control, startup & shutdown'''
    def __init__(self, config=None):
        self.cfg=None
        self.load_config(config)
        self.procs = []
        self.lock = True
        #self.load_modules()
    def load_modules(self):
        sys.path.append(self.cfg['application']['libs'])
        __import__ ('krolyk')
    def load_config(self, file):
        try:
            self.cfg = ConfigObj(file)
            sys.path.append(self.cfg['application']['plugins'])
        except Exception as err:
            print "Error reading config file. Reason: %s" % (err)
            sys.exit(1)        
    def block(self):
        return self.lock
    def doPID(self):
        if self.checkPIDRunning() == False:
            self.writePID()
    def checkPIDRunning(self):
        '''Checks whether the pid file exists and if it does, checks whether a process is running with that pid.
        Returns False when no process is running with that pid otherwise True'''
        if os.path.isfile(self.cfg['application']['pid']):
            try:
                pid_file = open(self.cfg['application']['pid'], 'r')
                pid=pid_file.readline()
                pid_file.close()
            except Exception as err:
                sys.stderr.write('I could not open the pid file. Reason: %s\n'%(err))
                sys.exit(1)
        try:
            os.kill(int(pid),0)
        except:
            return False
        else:
            sys.stderr.write('There is already a process running with pid %s\n'%(pid))
            sys.exit(1)             
    def writePID(self):
        try:
            pid = open ( self.cfg['application']['pid'], 'w' )
            pid.write (str(os.getpid()))
            pid.close()
        except Exception as err:
            sys.stderr.write('I could not write the pid file. Reason: %s\n'%(err))
            sys.exit(1)
    def deletePID(self):
        try:
            os.remove ( self.cfg['application']['pid'] )
        except:
            pass                
    def start(self):
        #Creating logging object
        self.logger()
        self.logging = logging.getLogger(__name__)

        self.logging.info('started')

        #Write PID
        self.doPID()
        
        #Initiate ModManager
        self.mod = krolyk.ModManager(block=self.block,cfg=self.cfg['plugins'])
        
        while self.block()==True:
            time.sleep(0.1)
        
        self.logging.info('Exit')
    def stop(self):
        self.logging.info('Received stop. Starting stop sequence.')
        self.lock=False
        for module in self.mod.register:
            for instance in self.mod.register[module]:
                if self.mod.register[module][instance].has_key('proc'):
                    self.mod.register[module][instance]['proc'].join()
    def logger(self,file=None, loglevel=logging.DEBUG):
        format=('%(asctime)s %(levelname)s %(name)s %(message)s')
        if file == None:
            logging.basicConfig(level=loglevel, format=format)
        else:
            print file
            logging.basicConfig(filename=file, level=loglevel, format=format)
            
if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option("--config", dest="config", default="/opt/krolyk/etc/krolyk.conf", type="string", help="The location of the config file." )
    (cli_options,cli_actions)=parser.parse_args()   
    
    try:
        if len (cli_actions) == 0:
            krolyk.Help()
            sys.exit(0)
        else:
            server=Server(config = cli_options.config)
            if cli_actions[0] == 'help':
                krolyk.Help()
                sys.exit(0)
            elif cli_actions[0] == 'start':
                with daemon.DaemonContext():
                    server.start()
            elif cli_actions[0] == 'debug':
                server.start()
            else:
                krolyk.Help()
                sys.exit(0)
    except Exception as err:
        print str(err)
    except KeyboardInterrupt:
        server.stop()
        server.deletePID()
