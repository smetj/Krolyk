#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       krolyk.py
#       
#       Copyright 2011 Jelle Smet <development@smetj.net>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#       
#       

import logging
import os
import sys
import pika
import time
from multiprocessing import Process, Manager, Queue
from pika.adapters import SelectConnection
from logging.handlers import SysLogHandler
from optparse import OptionParser
from configobj import ConfigObj
from string import find

__version__='0.1'

class Worker(Process):
    def __init__(self,config,cb_consume,block):
        Process.__init__(self)
        self.logging = logging.getLogger(__name__)
        self.c=config
        self.cb_consume=cb_consume
        self.block=block
        self.daemon=True
    def run(self):
        while self.block() == True:
            try:
                self.logging.debug('Started.')
                credentials = pika.PlainCredentials(self.c['_user'],self.c['_password'])
                self.parameters = pika.ConnectionParameters(self.c['_broker'],credentials=credentials)
                self.connection = SelectConnection(self.parameters,self.__on_connected) 
                try:
                    self.connection.ioloop.start()
                except KeyboardInterrupt:
                    self.connection.close()
                    self.connection.ioloop.start()
                    break
            except:
                self.logging.debug('Lost connection to Broker, sleeping and restarting.')
                time.sleep(1)               
    def __on_connected(self,connection):
        self.logging.info('Connecting to broker.')
        connection.channel(self.__on_channel_open)
    def __on_channel_open(self,new_channel):
        self.channel = new_channel
        self.__initialize()
        self.channel.basic_qos(prefetch_count=1)
        self.channel.basic_consume(self.cb_consume, queue = self.c['_queue'])
    def __initialize(self):
        self.logging.debug('Creating queues and bindings on broker.')                
        self.channel.queue_declare(queue=self.c['_queue'],durable=True)
    def acknowledge(self,tag):
        self.channel.basic_ack(delivery_tag=tag)

class ModManager():
    def __init__(self, cfg, block):
        self.logging = logging.getLogger(__name__)
        self.cfg=cfg
        self.block=block
        self.register={}
        self.__load()        
    def __load(self):
        for module in self.cfg:
            if self.cfg[module]['_enabled'] == 'True':
                try:
                    self.logging.info('Module %s enabled importing.' % module)
                    import mods
                    self.register[module]={}
                    for counter in range(int(self.cfg[module]['_workers'])):
                        self.register[module][counter]={}
                        self.register[module][counter]['mod'] = getattr(mods,module)()
                        self.register[module][counter]['mod'].config = self.__cleanConfig(self.cfg[module])
                        self.register[module][counter]['mod'].block = self.block
                                                
                        self.register[module][counter]['proc'] = Worker(config=self.cfg[module],
                                                                    cb_consume=self.register[module][counter]['mod'].consume,
                                                                    block=self.block)

                        self.register[module][counter]['mod'].acknowledge = self.register[module][counter]['proc'].acknowledge
                        
                        self.register[module][counter]['proc'].start()
                except:
                    self.logging.warning('Failed to load module %s' % module)
            else:
                self.logging.info('Module %s disabled.' % module)
    def __cleanConfig(self, config):
        cleaned={}
        for item in config:
            if find(item,'_') !=0:
                cleaned[item]=config[item]
        return cleaned
        
class Server():
    '''Server class handling process control, startup & shutdown'''
    def __init__(self, config=None):
        self.cfg=None
        self.load_config(config)
        self.procs = []
        self.lock = True
    def load_config(self, file):
        try:
            self.cfg = ConfigObj(file)
            sys.path.append(self.cfg['application']['modules'])
        except Exception as err:
            print "Error reading config file. Reason: %s" % (err)
            sys.exit(1)        
    def block(self):
        return self.lock
    def doPID(self):
        if self.checkPIDRunning() == False:
            self.writePID()
    def checkPIDRunning(self):
        '''Checks whether the pid file exists and if it does, checks whether a process is running with that pid.
        Returns False when no process is running with that pid otherwise True'''
        if os.path.isfile(self.cfg['application']['pid']):
            try:
                pid_file = open(self.cfg['application']['pid'], 'r')
                pid=pid_file.readline()
                pid_file.close()
            except Exception as err:
                sys.stderr.write('I could not open the pid file. Reason: %s\n'%(err))
                sys.exit(1)
        try:
            os.kill(int(pid),0)
        except:
            return False
        else:
            sys.stderr.write('There is already a process running with pid %s\n'%(pid))
            sys.exit(1)             
    def writePID(self):
        try:
            pid = open ( self.cfg['application']['pid'], 'w' )
            pid.write (str(os.getpid()))
            pid.close()
        except Exception as err:
            sys.stderr.write('I could not write the pid file. Reason: %s\n'%(err))
            sys.exit(1)
    def deletePID(self):
        try:
            os.remove ( self.cfg['application']['pid'] )
        except:
            pass                
    def start(self):
        #Creating logging object
        self.logger()
        self.logging = logging.getLogger(__name__)

        self.logging.info('started')

        #Write PID
        self.doPID()
        
        #Initiate ModManager
        self.mod = ModManager(block=self.block,cfg=self.cfg['modules'])
        
        while self.block()==True:
            time.sleep(0.1)
        
        self.logging.info('Exit')
    def stop(self):
        self.logging.info('Received stop. Starting stop sequence.')
        self.block=False
        for module in self.mod.register:
            for instance in self.mod.register[module]:
                self.mod.register[module][instance]['proc'].join()
    def logger(self,file=None, loglevel=logging.DEBUG):
        format=('%(asctime)s %(levelname)s %(name)s %(message)s')
        if file == None:
            logging.basicConfig(level=loglevel, format=format)
        else:
            print file
            logging.basicConfig(filename=file, level=loglevel, format=format)
            
class Help():
    def __init__(self):
        print ('Krolyk %s Copyright 2011 by Jelle Smet <development@smetj.net>' %(__version__))
        print ('''
        
Description:

    Krolyk consumes Nagios check results from RabbitMQ and writes these into the Nagios named pipe.
    
Usage :
        
    krolyk command --config name
    
    Valid commands:

        start       Starts Krolyk and forks into the background.
        stop        Stops Krolyk.   
        debug       Starts Krolyk into the foreground.
        help        Shows this help message.
    

    Parameters:

        config      Defines the location of the config file.


Krolyk is distributed under the Terms of the GNU General Public License Version 3. (http://www.gnu.org/licenses/gpl-3.0.html)

For more information please visit http://www.smetj.net/krolyk/
        ''')


if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option("--config", dest="config", default="/opt/krolyk/etc/krolyk.conf", type="string", help="The location of the config file." )
    (cli_options,cli_actions)=parser.parse_args()   
    
    try:
        server=Server(config = cli_options.config)
        if len (cli_actions) == 0:
            Help()
            sys.exit(0)
        if cli_actions[0] == 'help':
            Help()
            sys.exit(0)
        elif cli_actions[0] == 'start':
            with daemon.DaemonContext():
                server.start()
        elif cli_actions[0] == 'debug':
            server.start()
 #   except Exception as err:
 #       print str(err)
    except KeyboardInterrupt:
        server.stop()
        server.deletePID()
